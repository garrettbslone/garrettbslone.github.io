---
layout: default
title: "Weeks 7 & 8"
description: "Rasterization Pipeline"
---

<body xmlns="http://www.w3.org/1999/html">
<div class="content-border">
    <div class="content-group">
        <h2>Ray Tracing vs. Rasterization</h2>
        <p>
            Before we try to understand the what and how of rasterization, let's first take a look back at
            <a href="week4-5.html">Ray Tracing</a> to start understanding the why of it all. Ray tracing is a rather
            sraight forward and intuitive approach to rendering in which we send rays out, see what they intersect
            with, and determine how the light would reach that point. This process, while simple to understand,
            is incredibly intensive on the hardware because each frame we shoot a ray thru each pixel, then check
            every object to see if it was hit, then determine the lighting. With reflection and anti aliasing
            added on top of an already cumbersome process, the unfeasibility of ray tracing in real time
            becomes very apparent. This is also the reason that real time ray tracing is only starting to even
            be possible at all has happened within the last few years. So, the question remains: If ray tracing is
            to computationaly intensive how have images been rendered on computers for the past few decades?
            The answer, <b>Rasterization</b>. The main idea of the rasterization pipeline is essentially the
            reverse of ray tracing. Instead of checking each object inside of every pixel, let's just check each
            object once and then check if each pixel is covered by the object. One drawback however, is that
            rasterization makes it very difficult to create photorealistic images in terms of lighting and shading.
            This is because the objects in the scene are processed indepentent of one another, so they don't know
            their relative relationship (although I've been told there are tricks to help get around this).
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <img class="img-white-bg-card rec-400-300 rec-4-3-enlarge"
                     src="https://image1.slideserve.com/2059886/rasterization-vs-ray-tracing-l.jpg"
                     alt="Ray Tracing vs Rasterization (credit to: slideserve.com/palila/ray-tracing">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <img class="img-white-bg-card" style="width: 500px;"
                     src="http://www.pixelsham.com/wp-content/uploads/2019/10/ray_tracing_2.jpg"
                     alt="Ray Tracing vs Rasterization 2 (credit to: https://www.pixelsham.com/2019/10/24/whats-the-difference-between-ray-tracing-and-rasterization/)">
            </div>
        </div>
    </div>
    <br>

    <div class="content-group">
        <h2>The Rasterization Pipeline</h2>
        <p>
            Now that we have an understanding of why we want to use rasterizatrion, let's examine what the pipeline
            is. All of the images on the screen come down to pixels which can be filled with a single color. So how
            do we represent $2D$ and even $3D$ shapes on the screen? We use what are called polygon meshes. Polygon
            meshes are big compilations of conjoined polygons. The polygons can have any number of sides: triangle,
            rectangle, octogon, but the best one to use is the triangle. This is because triangles contain a few very
            helpful charactersitics. The <b>most</b> important of which is that they are <b>ALWAYS</b> guaranteed to be
            <b><u>planar</u></b> which means that for any triangle that exists, it does so entirenly within a singular
            plane. A nice consequence of being planar is that it is very easy to interpolate a color across a triangle
            because it only need to be interpolated within the plane that the triangle lives. These meshes can change
            the definition/quality by adding or removing more triangles (an subsequently resizing them). But, it does
            come at a cost of rendering time, so many techniques have been developed to allow only pieces of
            scenes to be rendered with high fidelity meshes by forms of culling. One of which will only render the part
            of a mesh that is visible, similar to how movie sets are built with facades.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>Triangle Meshes</p>
                <img class="img-white-bg-card rec-400-300 rec-4-3-enlarge"
                     src="https://qph.fs.quoracdn.net/main-qimg-857f4a334b2c3501d03f7b6812df4b49.webp"
                     alt="Triangle Meshes (credit to: https://www.quora.com/What-is-a-mesh-in-OpenGL)">
            </div>
        </div>
        <p>
            The graphics api really only needs to know about the verticies of these triangles, and each vertex will
            often contain more information that just spatial coordiantes, like coloring details. So to render an
            image on the screen we need to tell the hardware vertex information. Each vertex can be seen as a sample
            of the values for a give location, and the surfaces created between these vertecies are all approximations.
            The way that we are going to define these meshes is by a list of verticies (as decribed above) and a list
            of triplets of vertex indicies (from the list of vertexes) that relay how and in which direction each vertex
            is connected. Now that we know how to represent our objects let's take a (very) high view look at the
            pipeline itself.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>The Rasteization Pipeline</p>
                <img class="img-white-bg-card"
                     src="https://ciel1012.github.io/img/in-post/rtr2/2-1.png"
                     alt="The Rasterization Pipeline (credit to: https://ciel1012.github.io/2019/03/25/rtr2/)">
            </div>
        </div>
        <h2>The Application Stage</h2>
        <p>
            The application stage is the part where the program is running on the CPU. This stage contains thing like
            staging/preparing the data. This stage is also under full control of the developer, so any changes they
            want can be made here, and it is often a source improving performance by optimzing things like memory
            allocations. The most important job during this point is to prepare and submit the geometry (to the GPU)
            for rendering.
        </p>
        <h2>The Geometry Stage</h2>
        <p>
            The geometry stage is the point in the pipeline where per-vertex and per-primative (tirangle) operations
            happen.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>Geometry Processing</p>
                <img class="img-white-bg-card"
                     src="http://www.fragmentstorm.com/assets/images/2019-03-17-overview-of-the-graphics-pipeline/geometry-stage.png"
                     alt="Geometry Processing (credit to: http://www.fragmentstorm.com/overview-of-the-graphics-pipeline)">
            </div>
        </div>
        <p>
            The first thing that needs to happen is that all of the geometry in the scene needs to be transformed
            into multiple different coordinate systems. We will start with individual objects in their own object spaces
            where the origin can be anywhere but is almost always somewhere useful to whomever made the model. For
            something like a person it might be at the bottom of their foot to make it easy to place them on the ground.
            Then every model is taken into world space by multiplying it's coordinates by the world matrix, and in world
            space the origin is now set in the center of the scene. Then every object (now in world space) needs to be
            transformed so is is relative to the camera or view point. The camera is basically another object sitting
            anywhere in world space but by multiplying each object in world space by the inverse of the camera's world
            matrix, we can now see the scene with our camera set as the origin in what's called view space.
        </p>
        <h2>Vertex Shading</h2>
        <p>
            After we have our scene represented in the view space, it's time for the GPU to start with the vertex
            shading. Vertex shading is where the main vertex processing occurs, and it is where the transformation
            between coordinate spces would actually happen.
        </p>
        <h2>Projection and Clipping</h2>
        <p>
            Projection will take the $3D$ representation of the view space and map it down to a $2D$ representation.
            This can be done with multiple types of projections, but later in the coding part we'll be using perspective
            projection which will cause previously parallel lines to no longer be parallel and seemingly approach a
            single point, causing perspective (which is a more realistic way of looking at stuff than orthographic
            which preserves parallel lines). It will place everything withing a viewing frustum, or box, and then have
            every cooridate divided by the homogeneous coordinate $w$ to get the entire view volume to be within the
            range of $[-1,\ 1]$ along each axis also know as normalized device coordiantes. What happens to objects that
            are not entirely inside or outide of the viewing volume? Something called clipping is performed which
            creates new triangles by creating verticies at the edges and connecting them to primitives partially within
            the box. This way the hardware knows exactly how to render every primitive that can be seen.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <img class="img-white-bg-card"
                     src="http://www.fragmentstorm.com/assets/images/2019-03-17-overview-of-the-graphics-pipeline/clipping.png"
                     alt="Clipping (credit to: http://www.fragmentstorm.com/overview-of-the-graphics-pipeline)">
            </div>
        </div>
        <h2>Screen Mapping</h2>
        <p>
            After our scene has been clipped into a nice unit-cube, it is ready to translated into screen coordiantes.
            The entire view volume is expanded from the range for $x$ and $y$ vaues of $[-1,\ 1]$ to the size of
            the viewport also know as screen space. Every $(x,\ y)$ coordinate pair is now the position of a pixel
            on the screen.
        </p>
        <h2>Rasterization</h2>
        <p>
            Rasterization is the ending piece of the piepline where each of the primatives is broken down into
            individual fragments and colored. It begins by taking in the primatives (triangles) and then determining
            which pixels are covered by each one. The shaded value is then interpolated based on the position within
            the triangle and the values from each vertex.
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>Triangle Traversal</p>
                <img class="img-white-bg-card sq sq-enlarge"
                     src="http://www.fragmentstorm.com/assets/images/2019-03-17-overview-of-the-graphics-pipeline/triangle-traversal.png"
                     alt="Triangle Traversal (credit to: http://www.fragmentstorm.com/overview-of-the-graphics-pipeline)">
            </div>
        </div>
        <p>
            After the primatives have been rastered into fragments, the fragments are then shaded. Fragment shading
            is the point in the pipeline where per-fragment operations occur, and it is where the color is added to
            each fragment. According to OpenGL terminology, this stage is called fragment shading instead of pixel
            shading because each fragment is not guaranteed to correspond to an individual pixel. Then the interpolated
            colors are passed to the color buffer and then to the frame buffer and then to the screen for drawing.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>Pipeline Overview</p>
                <img class="img-white-bg-card rec-400-300 rec-4-3-enlarge"
                     src="https://opentechschool-brussels.github.io/intro-to-webGL-and-shaders/assets/log1_graphicPipeline.jpg"
                     alt="(credit to: https://opentechschool-brussels.github.io/intro-to-webGL-and-shaders/log1_graphic-pipeline)">
            </div>
        </div>
    </div>
    <br>

    <div class="content-group">
        <h2>Programming with WebGL</h2>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <img class="img-white-bg-card"
                     src="https://www.khronos.org/assets/uploads/apis/WebGL-Wide.png"
                     alt="WebGL Logo (credit to: https://www.khronos.org/webgl/)">
            </div>
        </div>
        <p>
            WebGL is a graphics API that allows us to interact with our GPU using javascript. It is built on top of
            the famous OpenGL ES (embedded systems) and GLSL (shader language). It is what is known as an
            immediate-mode rendering API. That basically means that the application issues all drawing commands for
            the entire scene each time a new frame is drawn; this allows a lot of control within the application
            program itself. A WebGL context is a state machine, so once an attribute is modified, it will remain
            that way until modified again. The way that we can interact with the graphics API is thru the html
            element <span class="eq">&lt;canvas></span> using a webgl context which looks something like the following,
            and it is where our coding journey begins.
        </p>
        <div class="eq">
            <pre>// get a reference to the canavs element from the DOM</pre>
            <pre>let canvas = document.getElementById("my-canvas");</pre>
            <br>
            <pre>// set the context to webgl</pre>
            <pre>let gl = canvas.getContext("webgl");</pre>
        </div>
        <p>
            Once we have that reference, we can start to render the scene. For this assignment the starter code I
            got went a long way, and setup both the vertex and fragment shaders, compiled and attached them to
            the WebGL context, setup some global reference variables, set the rendering function with the a
            background to a blue-ish color, and setup some scaffolding for the coming triangle and line geometries.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>Our Initial Scene</p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_bsq_1.png"
                     alt="blue square">
            </div>
        </div>

        <h2>Setting the Vewport Dimensions</h2>
        <p>
            Within our updateAndFunction is where we want to, well, render stuff, so this is where we'll want to
            set the size of the drawing space. We can do this using the dimensions of the canvas, and we might
            as well just take up the entire thing. One thing to note is that the gl reference can have arbitrary
            attributes attached to it, so it is a convenient place to store the width/height of the canvas
            without having to pass around both references. Note this function is also where the bacground color
            is being set to that blue-ish color via the <span class="eq">gl.clear</span>.
        </p>
        <div class="eq">
            <pre>// set the viewport to be te entire size of the canvas</pre>
            <pre>gl.viewport(0,                 // x coord of lower left corner</pre>
            <pre>            0,                 // y coord of lower left corner</pre>
            <pre>            gl.canvasWidth,    // width</pre>
            <pre>            gl.canvasHeight);  // height</pre>
            <br>
            <pre>// set the background color</pre>
            <pre>// set the gl color buffer attribute to the predefined color</pre>
            <pre>// each value between 0 and 1</pre>
            <pre>gl.clearColor(red, blue, green, alpha)</pre>
            <br>
            <pre>// actually reset the color buffer (and depth buffer)</pre>
            <pre>gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);</pre>
        </div>
        <br>

        <h2>Attaching the Shaders</h2>
        <p>
            Next we need to get the code for both the fragment and vertex shaders as text. We can do this
            similarly to how we got a reference to the canvas by using th DOM. Once we have the text we need to
            compile each of them. Once we've compiled all of our shaders, we need to create a shader program and link
            it to the WebGL context for the GPU to have access to them. Doing this still hasn't changed the scene
            at all since we are not drawing any geometry, so we still have that blue-ish square taking up the canvas.
        </p>
        <div class="eq">
            <pre>// get and compile the vertex shader</pre>
            <pre>let vertexShaderText = document.getElementById("my-vertex-shader").textContent;</pre>
            <pre>let vertexShader = gl.createShader(gl.VERTEX_SHADER);</pre>
            <pre>gl.shaderSource(vertexShader, vertexShaderText);</pre>
            <pre>gl.compileShader(vertexShader);</pre>
            <br>
            <pre>// get and compile the fragment shader</pre>
            <pre>let fragmentShaderText = document.getElementById("my-fragment-shader").textContent;</pre>
            <pre>let fragmentShader = gl.createShader(gl.Fragment_SHADER);</pre>
            <pre>gl.shaderSource(fragmentShader, fragmentShaderText);</pre>
            <pre>gl.compileShader(fragmentShader);</pre>
            <br>
            <pre>// create a gl "program" to hold our compiled shaders</pre>
            <pre>let shaderProgram = gl.createProgram();</pre>
            <br>
            <pre>// attach the shaders</pre>
            <pre>gl.attachShader(shaderProgram, vertexShader);</pre>
            <pre>gl.attachShader(shaderProgram, fragmentShader);</pre>
            <br>
            <pre>// link the shader program so gl (and the GPU) can use it</pre>
            <pre>gl.linkProgram(shaderProgram);</pre>
        </div>
        <br>

        <h2>Adding a Triangle</h2>
        <p>
            Now it's time to add a triangle to the middle of our scene. We can do this by setting the view point
            at a fixed position at the origin, and translating the triangle away from it. Then we can do a
            perspective projection on the triangle get it into clip space so that we can see it. It is super
            important to keep in mind that due to the right-hand rule $+z$ is coming out of the screen, so
            our displacement here should be in the $-z$ direction.
        </p>
        <div class="eq">
            <pre>// move the triangle 7 units infront of the camera</pre>
            <pre>triangleGeometry.worldMatrix.makeIdentity().makeTranslation(0, 0, -7);</pre>
            <br>
            <pre>// project the triangle</pre>
            <pre>// not that the projection matrix is global and not specific to the triangle</pre>
            <pre>projectionMatrix.makePerspective(45,                               // vertical fov</pre>
            <pre>                                 gl.canvasWidth / gl.canvasHeight, // aspect ratio</pre>
            <pre>                                 0.1,                              // near plane distance</pre>
            <pre>                                 1000);                            // far plane distance</pre>
            <br>
            <pre>// send the matricies to the shader using the transpose of the elements</pre>
            <pre>// since the GPUs like to have the elements ordered as column vectors for</pre>
            <pre>// a performance reasons</pre>
            <pre>gl.uniformMatrix4fv(shaderProgram.worldMatrixUniform,</pre>
            <pre>                    false,</pre>
            <pre>                    triangleGeometry.worldMatrix.clone().transpose().elements)</pre>
            <br>
            <pre>// repeat the above with the viewMatrix and projection matrix</pre>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box dual-grid-box-img">
                <p>Big Triangle</p>
                <img class="img-white-bg-card rec-300-250"
                     src="../../assets/img/wgli_btr_1.png"
                     alt="Black Triangle">
            </div>
            <div class="img-grid-box dual-grid-box-img">
                <p>That looks more like 7</p>
                <img class="img-white-bg-card rec-300-250"
                     src="../../assets/img/wgli_sm_btr_1.png"
                     alt="Black Triangle">
            </div>
        </div>

        <h2>Adding Some Color</h2>
        <p>
            Now that we have the geometry for the triangle setup, lets color that thing. The first thing we need to
            do to is to create and bind a color buffer which is something I didn't mention earlier when talking
            about the verticies. In order to allocated some space in VRAM (memory on the graphics card), we need to
            create a buffer, set it up in a javascript Float32Array, bind the buffer, and then pass the data over to
            the video card. The color buffer for the triangle is an array of 3 colors (3 triplets; 9 floats) that
            correspond to each vertex in the triangle. Each triplet is compsed of 3 floats from 0 to 1 that represent
            a value for the Red, Green, and Blue channels respectively.
        </p>
        <div class="eq">
            <pre>// 1. create color buffer</pre>
            <pre>// allocating space in VRAM</pre>
            <pre>let newColorBuffer = gl.createBuffer();</pre>
            <br>
            <pre>// 2. bind color buffer</pre>
            <pre>gl.bindBuffer(gl.ARRAY_BUFFER, newColorBuffer);</pre>
            <br>
            <pre>// 3. create color array</pre>
            <pre>let colors = [</pre>
            <pre>   1.0, 0.0, 0.0,  // red</pre>
            <pre>   0.0, 1.0, 0.0,  // green</pre>
            <pre>   0.0, 0.0, 1.0   // blue</pre>
            <pre>];</pre>
            <br>
            <pre>// 4. "buffer" color data</pre>
            <pre>// copy the buffer from RAM to VRAM</pre>
            <pre>gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);</pre>
            <br>
            <pre>// 5. store a reference to the color buffer on the triangleGeometry object</pre>
            <pre>triangleGeometry.colorBuffer = newColorBuffer;</pre>
        </div>
        <p>
            Next we need to add a new attribute to the vertex shader to handle the color as well as a new varying
            to both the vertex and fragment shaders. What do attribute and varying mean? Well, an attribute is
            a piece of information that is only available in the <b>Vertex</b> shader, and a varying variable is
            a variable that is passed as output of the vertex shader and as input to the fragment shader. Varying
            variables have values accessable in both types of shaders. Since the fragment shader we were given
            already has the varying color, we just need to take care of the vertex shader for now.
        </p>
        <span style="text-align: center;">Vertex Shader</span>
        <div class="eq">
            <pre>attribute vec3 aVertexColor;</pre>
            <pre>...</pre>
            <br>
            <pre>varying vec3 vColor;</pre>
            <br>
            <pre>void main(void) {</pre>
            <pre>   ...</pre>
            <pre>   vColor = aVertexColor;</pre>
            <pre>}</pre>
        </div>
        <p>
            Next we need to get a reference to the color shader attribute, and then bind the color buffer to
            the attribute. We can get the attribute and attach the reference to the shaderProgram and then
            enable it for use.
        </p>
        <div class="eq">
            <pre>// Get a reference to the color attribute variable in the vertex shader and enable it</pre>
            <pre>shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");</pre>
            <pre>gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);</pre>
            <br>
            <pre>// bind te color buffer for use in the shader program</pre>
            <pre>gl.bindBuffer(gl.ARRAY_BUFFER, triangleGeometry.colorBuffer);</pre>
            <pre>gl.vertexAttribPointer(</pre>
            <pre>   triangleGeometry.shaderProgram.vertexColorAttribute,</pre>
            <pre>   3,          // number of verticies</pre>
            <pre>   gl.FLOAT,   // type</pre>
            <pre>   gl.FALSE,   // normalized?</pre>
            <pre>   0,          // stride (no idea what this does)</pre>
            <pre>   0,          // offset from first compoenent in the attribute array</pre>
            <pre>);</pre>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>A nice Colored Triangle</p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_ctr_1.png">
            </div>
        </div>

        <h2>Rotating the Triangle</h2>
        <p>
            In order to rotate the triangle, we just need to apply a rotation around the $y-axis$, but we need to make
            sure that the rotation is applied after the transation so that the triangle is rotating about its center
            and not the world origin at a distance of 7 units. The way we can roate the triangle is by using the time
            elapsed since the program has sarted running which will be passed in as an argument to the updateAndRender
            function. From there we need to make sure it's a number (since at the very beginning it
            seems to be undefined) then convert it to seconds from miliseconds and we can use that to find the
            degrees to rotate.
        </p>
        <div class="eq">
            <pre>function updateAndRender(s) {</pre>
            <pre>   time.secondsElapsedSinceStart = !isNaN(s) ? s / 1000 : 0;</pre>
            <br>
            <pre>   ...</pre>
            <br>
            <pre>   // calculate the number of degrees we should have rotated given how much time has elapsed</pre>
            <pre>   // 60 degrees per second</pre>
            <pre>   var degrees = time.secondsElapsedSinceStart * 60;</pre>
            <br>
            <pre>   ...</pre>
            <br>
            <pre>   // setup the rotation</pre>
            <pre>   let triangleRot = new Matrix4().makeRotationY(degrees);</pre>
            <br>
            <pre>   ...</pre>
            <br><br>
            <pre>   // combine the rotation with the translation</pre>
            <pre>   let triangleTransl = new Matrix4().makeTranslation(0, 0, -7);</pre>
            <pre>   triangleGeometry.worldMatrix = triangleTransl.multiply(triangleRot);</pre>
            <pre>}</pre>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p class="dual-grid-box-img dual-grid-box-img">??? Turns out my projection matrix wasn't quite right</p>
                <img class="img-white-bg-card rec-300-250"
                     src="../../assets/img/wgli_ctr_rot_1.gif">
            </div>
            <div class="img-grid-box">
                <p class="dual-grid-box-img dual-grid-box-img">Waaaay too fast. Forgot to covert the time from
                    miliseconds to seconds</p>
                <img class="img-white-bg-card rec-300-250"
                     src="../../assets/img/wgli_ctr_rot_2.gif">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p class="dual-grid-box-img">Much better</p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_ctr_rot_3_c.gif">
            </div>
        </div>

        <h2>Adding a Grid Line Plane</h2>
        <p>
            As of right now we have a singular spinning triangle set in space somewhere on a blue-ish background, but
            we don't have any other sense of where we are and we have no real sense of direction. How can we make it
            easier to visualize the space of the WebGL context? We can add a plane beneath the triangle made up of
            grid lines. One super important thing to keep in mind now is that we need to display objects based on
            their distance to the camera; in other words, we only want to see the closest object to us (since
            everything is opaque). To do this we need to enable the depth test to compare the $z-coordinates$ of
            each vertex, and this will allow the grid to be displayed behind/below the triangle. First let's start by
            defining the verticies to decribe the lines. Note that we are setting the $y-value$ of each coordinate
            to $-1$ since that is how far down the unit cube goes, and it will make sure that the tirangle is above the
            lines.
        </p>
        <div class="eq">
            <pre>var linePositions = [];</pre>
            <br>
            <pre>// specify the horizontal lines</pre>
            <pre>for (var i = -10; i <= 10; ++i) {</pre>
            <pre>   // add position for line start point (x value should be i)</pre>
            <pre>   linePositions.push(i, -1, 10);</pre>
            <pre>   // add position for line end point (x value should be i)</pre>
            <pre>   linePositions.push(i, -1, -10);</pre>
            <pre>}</pre>
            <br>
            <pre>// specify the lateral lines</pre>
            <pre>  for (var i = -10; i <= 10; ++i) {</pre>
            <pre>   // add position for line start point (z value should be i)</pre>
            <pre>   linePositions.push(-10, -1, i);</pre>
            <pre>   // add position for line end point (z value should be i)</pre>
            <pre>   linePositions.push(10, -1, i);</pre>
            <pre>}</pre>
        </div>
        <p>
            After creating the verticies in $linePositions$ array which is bound an then enabled to the gl context,
            we need to project the line grid into our scene the same way we did the triangle, and we end up
            with the following scene.
        </p>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_grl_1_c.gif">
            </div>
        </div>

        <h2>Adventures in (Fragment) Shading</h2>
        <p>
            Ok, so to be completely honest I don't exactly undersand what's going on here, but here's my attempts
            to animate the colors based on the elapsed time. Also a quick note that I was sending the degrees
            (time elasped/ 60) to the fragment shader on accident instead of just the time elapsed. Below are
            the variables as defined in my fragment shader.
            <br>
            P.S.: Sorry they're listed one at a time I couldn't get the styling to display the vectors properly
            when I had 2 to a row.
        </p>
        <div class="eq">
            <pre>// setting floating point precision</pre>
            <pre>precision mediump float;</pre>
            <br>
            <pre>// time elasped since program start (t/60) </pre>
            <pre>uniform float uTime;</pre>
            <br>
            <pre>// vertex color and positions</pre>
            <pre>varying vec3 vColor;</pre>
            <pre>varying vec3 vPosition;</pre>
            <br>
            <pre>void main(void) {</pre>
            <pre>   float _rads = radians(uTime);</pre>
            <pre>   float _dot = dot(vColor, vPosition);</pre>
            <br>
            <pre>   // Not sure these really have any meaning</pre>
            <pre>   // but I was having fun :)</pre>
            <pre>   vec3 _cross_cp = cross(vColor, vPosition);</pre>
            <pre>   vec3 _cross_pc = cross(vPosition, vColor);</pre>
            <br>
            <pre>   // we send a value of 1.0 as the 4th element to the alpha channel</pre>
            <pre>   // meaning fully opaque</pre>
            <pre>   gl_FragColor = vec4(vec3-above-each-img, 1.0)</pre>
            <pre>}</pre>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    cos(uTime) \\
                    cos(uTime) \\
                    cos(uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_1.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    cos(vColor.x\ +\ uTime) \\
                    sin(vColor.y\ +\ uTime) \\
                    cos(vColor.z\ +\ uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_2.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    cos(vColor.x) \\
                    sin(vColor.y) \\
                    cos(vColor.z)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_3.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    cos(\_rads) \\
                    sin(\_rads) \\
                    cos(\_rads)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_4.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\_rads) \\
                    fract(\_rads) \\
                    fract(\_rads)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_5.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(uTime) \\
                    fract(uTime) \\
                    fract(uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_6.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    cos(fract(uTime)) \\
                    fract(sin(\_rads)) \\
                    cos(fract(uTime))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_7.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    sin(vColor.x\ +\ sin(uTime)) \\
                    cos(vColor.y\ +\ cos(uTime)) \\
                    sin(vColor.z\ +\ fract(uTime))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_8.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    sin(vColor.x\ +\ \_rads) \\
                    cos(vColor.y\ +\ \_rads) \\
                    sin(vColor.z\ +\ \_rads)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_9.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ +\ \_rads) \\
                    fract(vColor.y\ +\ \_rads) \\
                    fract(vColor.z\ +\ \_rads)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_10.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ +\ sin(uTime)) \\
                    fract(vColor.y\ +\ fract(uTime)) \\
                    fract(vColor.z\ +\ cos(uTime))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_11.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x)\ +\ sin(\_rads) \\
                    fract(vColor.y)\ +\ sin(\_rads) \\
                    fract(vColor.z)\ +\ sin(\_rads)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_12.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(sin(vColor.x\ +\ sin(\_rads))) \\
                    fract(sin(vColor.y\ +\ sin(\_rads))) \\
                    fract(sin(vColor.z\ +\ sin(\_rads)))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_13.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ +\ 0.2\ +\ sin(\_rads)) \\
                    fract(vColor.y\ -\ 0.3\ +\ fract(uTime)) \\
                    fract(vColor.z\ *\ 0.32\ +\ cos(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_14.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ *\ \_dot\ +\ sin(\_rads)) \\
                    fract(vColor.y\ *\ \_dot\ +\ sin(\_rads)) \\
                    fract(vColor.z\ *\ \_dot\ +\ sin(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_15.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vPosition.x\ *\ \_dot\ +\ sin(\_rads)) \\
                    fract(vPosition.y\ *\ \_dot\ +\ sin(\_rads)) \\
                    fract(vPosition.z\ *\ \_dot\ +\ sin(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_16.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ +\ \_dot\ +\ cos(\_rads)) \\
                    fract(vColor.y\ +\ \_dot\ +\ cos(\_rads)) \\
                    fract(vColor.z\ +\ \_dot\ +\ cos(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_17.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\frac{vColor.x}{\_dot}\ -\ uTime) \\
                    fract(\frac{vColor.y}{\_dot}\ -\ uTime) \\
                    fract(\frac{vColor.z}{\_dot}\ -\ uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_18.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ -\ \_dot\ -\ uTime) \\
                    fract(vColor.y\ +\ \_dot\ +\ uTime) \\
                    fract(vColor.z\ +\ \_dot\ -\ uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_19.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vColor.x\ +\ sin(\_dot)) \\
                    fract(vColor.y\ +\ sin(\_dot)) \\
                    fract(\frac{sin(\_rads)}{vColor.z})
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_20.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\frac{vColor.x}{sin(\_dot)}\ *\ cos(\_rads)) \\
                    fract(vColor.y\ +\ sin(\_rads\ *\ \_dot)) \\
                    fract(\frac{sin(\_rads)}{cos(vColor.z\ +\ \_dot)})
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_21.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\frac{sin(\frac{\_rads}{\_dot})}{vColor.x\ +\ 0.1}) \\
                    fract(\frac{sin(\frac{\_rads}{\_dot})}{vColor.y\ +\ 0.1}) \\
                    fract(\frac{sin(\frac{\_rads}{\_dot})}{vColor.z\ +\ 0.1})
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_22.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    \frac{vColor.x\ +\ vColor.x}{fract(sin(\frac{\_rads}{\_dot}))} \\
                    \frac{vColor.y\ +\ vColor.z}{fract(sin(\frac{\_rads}{\_dot}))} \\
                    \frac{vColor.y\ +\ vColor.z}{fract(sin(\frac{\_rads}{\_dot}))}
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_23.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract((vColor.x\ +\ vPosition.x)\ *\ sin(\_rads)) \\
                    fract((vColor.y\ +\ vPosition.y)\ *\ sin(\_rads)) \\
                    fract((vColor.z\ +\ vPosition.z)\ *\ sin(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_24.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(cos((vColor.x\ +\ vPosition.x)\ *\ \_rads)) \\
                    fract(cos((vColor.y\ +\ vPosition.y)\ *\ \_rads)) \\
                    fract(cos((vColor.z\ +\ vPosition.z)\ *\ \_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_25.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract((vColor.x\ +\ vPosition.x)\ * uTime) \\
                    fract((vColor.y\ +\ vPosition.y)\ * uTime) \\
                    fract((vColor.z\ +\ vPosition.z)\ * uTime) \\
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_26.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\_cross\_cp.x\ *\ sin(\_rads)) \\
                    fract(\_cross\_cp.y\ *\ sin(\_rads)) \\
                    fract(\_cross\_cp.z\ *\ sin(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_27.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\_cross\_cp.x\ +\ \_dot\ *\ sin(\_rads)) \\
                    fract(\_cross\_cp.y\ +\ \_dot\ *\ sin(\_rads)) \\
                    fract(\_cross\_cp.z\ +\ \_dot\ *\ sin(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_28.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\_cross\_pc.x\ +\ vPosition.x\ +\ uTime\ +\ vColor.x\ +\ cos(\_rads)) \\
                    fract(\_cross\_pc.y\ +\ vPosition.y\ +\ uTime\ +\ vColor.y\ +\ cos(\_rads)) \\
                    fract(\_cross\_pc.z\ +\ vPosition.z\ +\ uTime\ +\ vColor.z\ +\ cos(\_rads))
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_29.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(\_cross\_cp.z\ -\ vPosition.x\ +\ uTime) \\
                    fract(\_cross\_cp.z\ -\ vPosition.z\ +\ uTime) \\
                    fract(\_cross\_cp.z\ -\ vPosition.z\ +\ uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_30.gif"
                     alt="Antimated Light">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box">
                <p>
                    $\begin{pmatrix}
                    fract(vPosition.x\ +\ \_dot\ *\ uTime) \\
                    fract(\_cross\_cp.z\ -\ vPosition.z\ +\ uTime) \\
                    fract(\_cross\_cp.z\ -\ vPosition.z\ +\ uTime)
                    \end{pmatrix}$
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_vc_31.gif"
                     alt="Antimated Light">
            </div>
        </div>

        <h2>Making a movable Camera</h2>
        <p>
            For this last piece here, the goal is to be able to move the camera around and keep the scene in tact. I started
            by defining a world matrix and well as a movement speed step for the camera. Then I setup a keydown
            listener and added the step to matrix based on which key was pressed. Lastly, I multiplied the view matrix
            by the camera's world matrix to transform the view to be aligned with the camera.
        </p>
        <div class="eq">
            <pre>// first setup some global variables</pre>
            <pre>const CAMERA_MOVEMENT_SPEED_STEP = 0.1;</pre>
            <pre>let camera = {</pre>
            <pre>   worldMatrix: null,</pre>
            <pre>   e: null, </pre>
            <pre>}</pre>
            <br>
            <pre>...</pre>
            <br>
            <pre>// then in the init function setup the matrix and a</pre>
            <pre>// shorthand reference to the elements</pre>
            <pre>camera.worldMatrix = new Matrix4();</pre>
            <pre>camera.e = camera.worldMatrix.elements;</pre>
            <br>
            <pre>...</pre>
            <br>
            <pre>window.addEventListener("keydown", (event) => {</pre>
            <pre>   if (event.key === "w" || event.key === "ArrowUp") {</pre>
            <pre>       camera.worldMatrix.makeTranslation(camera.e[3],</pre>
            <pre>                                           camera.e[7],</pre>
            <pre>                                           camera.e[11] + CAMERA_MOVEMENT_SPEED_STEP);</pre>
            <pre>   } else if (event.key === "a" || event.key === "ArrowLeft") {</pre>
            <pre>       camera.worldMatrix.makeTranslation(camera.e[3] + CAMERA_MOVEMENT_SPEED_STEP,</pre>
            <pre>                                           camera.e[7],</pre>
            <pre>                                           camera.e[11]);</pre>
            <pre>   } else if (event.key === "s" || event.key === "ArrowDown") {</pre>
            <pre>       camera.worldMatrix.makeTranslation(camera.e[3],</pre>
            <pre>                                           camera.e[7],</pre>
            <pre>                                           camera.e[11] - CAMERA_MOVEMENT_SPEED_STEP);</pre>
            <pre>   } else if (event.key === "d" || event.key === "ArrowRight") {</pre>
            <pre>       camera.worldMatrix.makeTranslation(camera.e[3] - CAMERA_MOVEMENT_SPEED_STEP,</pre>
            <pre>                                           camera.e[7], </pre>
            <pre>                                           camera.e[11]);</pre>
            <pre>   }</pre>
            <pre>});</pre>
            <br>
            <pre>...</pre>
            <br>
            <pre>// move the view along with the camera</pre>
            <pre>viewMatrix.multiply(camera.worldMatrix);</pre>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box dual-grid-box-img">
                <p>
                    If Neo was a triangle... Caused
                    by multiplying the grid line and triangle
                    world matricies by the inverse of the
                    camera world matrix
                </p>
                <img class="img-white-bg-card rec-300-250"
                     src="../../assets/img/wgli_cm_1.gif"
                     alt="Movable Camera">
            </div>
            <div class="img-grid-box dual-grid-box-img">
                <p>
                    The triagnle shouldn't be moving like that...
                    Caused by multiplying the triangle world matrix
                    by the camera world matrix
                </p>
                <img class="img-white-bg-card rec-300-250"
                     src="../../assets/img/wgli_cm_2.gif"
                     alt="Movable Camera">
            </div>
        </div>
        <div class="img-flex-wrap">
            <div class="img-grid-box ">
                <p>
                    That looks pretty good!
                </p>
                <img class="img-white-bg-card rec-450-300"
                     src="../../assets/img/wgli_cm_3_c.gif"
                     alt="Movable Camera">
            </div>
        </div>
    </div>
    <br>
    
    <div id="webgl-guide" style="display: none;">
        1. get canvas id for webgl ctx (blue sq)
        2. set the viewport dimensons (blue sq)
        3. get shaders text (blue sq)
        4. compile shader (blue sq)
        5. attach the shader program (black triangle)
        6. translate the triangle away from the camera (smaller black trianle)
        7. create/fill/bind color buffer for triangle (smaller back triangle)
        8. add color to vertex shader (smaller back triangle)
        9. get ref to color buffer causeing invalid operation (no triangle)
        10. bind the color buffer (colored triangle)
        11. rotate the tringle (rotating tri)
        - 1 = ?
        - 2 = miliseconds
        12. add the grid lines (grid below spinning triangle)
        13. animate color bvy time
        - 1 = all cos(uTime)
        - 2 = cos(vColor.x + uTime), sin(vColor.y + uTime), cos(vColor.z + uTime)
        - 3 = cos(vColor.x), sin(vColor.y), cos(vColor.z)
        - 4 = cos(radians(uTime)), sin(radians(uTime)), cos(radians(uTime))
        - 5 = fract(radians(uTime)), fract(radians(uTime)), fract(radians(uTime))
        - 6 = fract(uTime), fract(uTime), fract(uTime)
        - 7 = cos(fract(uTime)), fract(sin(radians(uTime))), cos(fract(uTime))
        - 8 = sin(vColor.x + sin(uTime)), cos(vColor.y + cos(uTime)), sin(vColor.z + fract(uTime))
        - 9 = sin(vColor.x + radians(uTime)), cos(vColor.y + radians(uTime)), sin(vColor.z + radians(uTime))
        - 10 = fract(vColor.x + radians(uTime)), fract(vColor.y + radians(uTime)), fract(vColor.z + radians(uTime))
        - 11 = fract(vColor.x + sin(uTime)), fract(vColor.y + fract(uTime)), fract(vColor.z + cos(uTime))
        - 12 = fract(vColor) + sin(radians(uTime))
        - 13 = fract(sin(vColor + sin(radians(uTime))))
        - 14 = fract(vColor.x + 0.2 + sin(radians(uTime))), fract(vColor.y - 0.3 + fract(uTime)), fract(vColor.z * 0.32
        + cos(radians(uTime)))
        - 15 = fract(vColor * dot(vColor, vPosition) + sin(rads))
        - 16 = fract(vPosition * dot(vColor, vPosition) + sin(rads))
        - 17 = fract(vColor + dot(vColor, vPosition) + cos(rads))
        - 18 = fract(vColor / dot(vColor, vPosition) - uTime)
        - 19 = fract(vColor.x - loc - uTime), fract(vColor.y + loc + uTime), fract(vColor.z + loc - uTime)
        - 20 = fract(vColor.x + sin(loc)), fract(vColor.y + sin(rads)), fract(sin(rads) / vColor.z)
        - 21 = fract(vColor.x / sin(loc) * cos(rads)), fract(vColor.y + sin(rads * loc)), fract(sin(rads) / cos(vColor.z
        + loc))
        - 22 = fract(sin(rads / loc) / (vColor + 0.1))
        - 23 = (vColor + vColor) / fract(sin(rads / loc))
        - 24 = fract((vColor + vPosition) * sin(rads))
        - 25 = fract(cos((vColor + vPosition) *rads))
        - 26 = fract((vColor + vPosition) * uTime)
        - 27 = fract(_cross_cp * sin(rads)
        - 28 = fract(_cross_cp + _dot * sin(_rads))
        - 29 = fract(_cross_pc + (vPosition + uTime + vColor) + cos(_rads))
        - 30 = fract(_cross_cp.z - vPosition.x + uTime), fract(_cross_cp.z - vPosition.z + uTime), fract(_cross_cp.z -
        vPosition.z + uTime)
    </div>

    <h3>Image Sources</h3>
    <ol>
        <li>
            <a href="slideserve.com/palila/ray-tracing">
                Ray Tracing vs. Rasterization</a>
        </li>
        <li>
            <a href="https://www.pixelsham.com/2019/10/24/whats-the-difference-between-ray-tracing-and-rasterization/">
                Ray Tracing vs. Rasterization 2</a>
        </li>
        <li>
            <a href="https://www.quora.com/What-is-a-mesh-in-OpenGL">
                Triangle Meshes</a>
        </li>
        <li>
            <a href="https://ciel1012.github.io/2019/03/25/rtr2/">
                The Rasterization Pipeline</a>
        </li>
        <li>
            <a href="http://www.fragmentstorm.com/overview-of-the-graphics-pipeline">
                Geometry Processing</a>
        </li>
        <li>
            <a href="http://www.fragmentstorm.com/overview-of-the-graphics-pipeline">
                Clipping</a>
        </li>
        <li>
            <a href="http://www.fragmentstorm.com/overview-of-the-graphics-pipeline">
                Triangle Traversal</a>
        </li>
        <li>
            <a href="https://opentechschool-brussels.github.io/intro-to-webGL-and-shaders/log1_graphic-pipeline">
                Pipeline Overview</a>
        </li>
        <li>
            <a href="https://www.khronos.org/webgl/">
                WebGL Logo</a>
        </li>
    </ol>
</div>
</body>